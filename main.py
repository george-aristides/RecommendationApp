import requests
import subprocess

API_KEY = ""
BASE_URL = "https://api.themoviedb.org/3"

def fetch_genres(language="en-US"):
    """
    Fetch the list of genres from the TMDB API.

    :param language: Language for the genre names (default is English).
    :return: Dictionary of genres with their IDs and names.
    """
    endpoint = f"{BASE_URL}/genre/movie/list"
    params = {
        "api_key": API_KEY,
        "language": language,
    }
    response = requests.get(endpoint, params=params)
    if response.status_code == 200:
        genres = response.json().get("genres", [])
        return {genre["id"]: genre["name"] for genre in genres}
    else:
        print(f"Error: Unable to fetch genres (status code {response.status_code})")
        return {}

def get_movies_by_genre(genre_id, page, language="en-US"):
    """
    Fetch movies by genre using TMDB API.

    :param genre_id: The ID of the genre to fetch movies for.
    :param page: The page number to fetch.
    :param language: Language of the movie results (default is English).
    :return: JSON response containing the list of movies.
    """
    endpoint = f"{BASE_URL}/discover/movie"
    params = {
        "api_key": API_KEY,
        "language": language,
        "with_genres": genre_id,
        "page": page,
    }
    response = requests.get(endpoint, params=params)
    if response.status_code == 200:
        data = response.json()
        total_movies = data["total_results"]
        print("The total movies in that genre is:", total_movies)
        return response.json()
    else:
        print(f"Error: Unable to fetch data (status code {response.status_code})")
        return None

def generate_response_with_ollama(model_name, prompt):
    """
    Generate a response using the LLaMA model via Ollama.

    :param model_name: Name of the model in Ollama.
    :param prompt: The prompt to send to the model.
    :return: The generated response from the model.
    """
    command = ['ollama', 'run', model_name, prompt]
    result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    if result.returncode == 0:
        return result.stdout.strip()
    else:
        print("Error in generating response:", result.stderr)
        return None

def determine_mbti_type(personality_traits, model_name="llama3.1"):
    """
    Determine the user's MBTI type based on their personality traits.

    :param personality_traits: The personality traits generated by LLaMA.
    :param model_name: Name of the LLaMA model in Ollama.
    :return: The determined MBTI type.
    """
    prompt = (
        f"The user has these personality traits: {personality_traits}. "
        "Based on these traits, determine which of the 16 MBTI personality types the user fits best."
    )
    mbti_type = generate_response_with_ollama(model_name, prompt)
    return mbti_type

def recommend_books(mbti_type, model_name="llama3.1"):
    """
    Recommend three books based on the user's MBTI type.

    :param mbti_type: The MBTI type of the user.
    :param model_name: Name of the LLaMA model in Ollama.
    :return: A list of three recommended books.
    """
    prompt = (
        f"The user's MBTI personality type is {mbti_type}. "
        "Based on this personality type, recommend three books for the user."
    )
    book_recommendations = generate_response_with_ollama(model_name, prompt)
    return book_recommendations

def main():
    genres = fetch_genres()

    if not genres:
        print("Failed to retrieve genres. Exiting.")
        return

    print("Available Genres:")
    genre_list = list(genres.items())
    for idx, (genre_id, genre_name) in enumerate(genre_list, start=1):
        print(f"{idx}. {genre_name}")

    try:
        choice = int(input("\nChoose a genre by number: "))
        if 1 <= choice <= len(genre_list):
            genre_id, genre_name = genre_list[choice - 1]

            selected_movies = []
            page = 1
            while len(selected_movies) < 3:
                movies = get_movies_by_genre(genre_id, page)
                if movies:
                    print(f"\nMovies in the {genre_name} genre (Page {page}):")
                    for idx, movie in enumerate(movies['results'], start=1):
                        print(f"{idx}. {movie['title']}")

                    try:
                        max_selections = min(3 - len(selected_movies), len(movies['results']))
                        user_choices = input(
                            f"\nSelect movies by number (comma-separated, max {max_selections} selections): "
                        ).strip()
                        selected_indices = [int(x.strip()) for x in user_choices.split(",")]

                        for index in selected_indices:
                            if 1 <= index <= len(movies['results']):
                                selected_movie = movies['results'][index - 1]['title']
                                if selected_movie not in selected_movies:
                                    selected_movies.append(selected_movie)
                                    print(f"Added: {selected_movie}")
                                else:
                                    print(f"{selected_movie} is already selected.")
                                    continue
                            else:
                                print(f"Invalid selection: {index}")

                            if len(selected_movies) >= 3:
                                break

                        if len(selected_movies) >= 3:
                            break
                    except ValueError:
                        print("Invalid input. Please enter valid numbers separated by commas.")

                if len(selected_movies) < 3:
                    answer = input("Do you want more movies in this genre? (Y/N): ").strip().upper()
                    if answer == "N":
                        print("Goodbye!")
                        return
                    elif answer == "Y":
                        print("Fetching more movies...")
                        page += 1
                    else:
                        print("Invalid input. Please enter 'Y' for yes or 'N' for no.")
                else:
                    break

            print("\nYour top 3 movies:")
            for movie in selected_movies:
                print(f"- {movie}")

            # Step 1: Generate personality traits
            prompt = (
                f"The user selected these movies: {', '.join(selected_movies)}. "
                "Based on these choices, describe this user in three personality traits."
            )
            model_name = "llama3.1"  # Replace with your model's name in Ollama
            print("\nGenerating personality traits based on your movie selections...\n")
            personality_traits = generate_response_with_ollama(model_name, prompt)

            if personality_traits:
                print("Here are three personality traits that describe you:")
                print(personality_traits)
            else:
                print("Failed to generate personality traits.")
                return

            # Step 2: Determine MBTI type
            print("\nDetermining your MBTI type based on your personality traits...\n")
            mbti_type = determine_mbti_type(personality_traits, model_name)
            if mbti_type:
                print(f"Your MBTI personality type is: {mbti_type}")
            else:
                print("Failed to determine MBTI personality type.")
                return

            # Step 3: Recommend books
            print("\nRecommending books based on your MBTI type...\n")
            book_recommendations = recommend_books(mbti_type, model_name)
            if book_recommendations:
                print("Here are three book recommendations for you:")
                print(book_recommendations)
            else:
                print("Failed to generate book recommendations.")

        else:
            print("Invalid choice. Please run the program again.")
    except ValueError:
        print("Invalid input. Please enter a number.")

if __name__ == "__main__":
    main()
